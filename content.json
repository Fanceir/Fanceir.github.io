[{"title":"堆地址与栈地址","date":"2024-08-04T14:10:20.000Z","path":"2024/08/04/堆地址与栈地址/","excerpt":""},{"title":"HTTP缓存技术","date":"2024-07-23T15:27:48.000Z","path":"2024/07/23/HTTP缓存技术/","excerpt":""},{"title":"JavaScript的Set","date":"2024-07-18T14:09:29.000Z","path":"2024/07/18/JavaScript的Set/","excerpt":"Javascript的Set 在ES6中新增了Set这个数据结构，它类似于数组，但是成员的值都是唯一的，没有重复的值。 注意的是不同于CPP的set，Javascript的Set是没有排序的 这里介绍一下Set的基本用法 12let set = new Set([1, 2, 3, 4, 4]);console.log(set); // Set(4) &#123; 1, 2, 3, 4 &#125; 这里我将一个数组传入了Set，Set会自动去重，所以最后的结果是Set(4) &#123; 1, 2, 3, 4 &#125; 当然你也可以通过add方法添加元素 123456let arr = [1, 2, 3, 4, 4];let set = new Set();arr.forEach((item) =&gt; &#123; set.add(item);&#125;);console.log(set); // Set(4) &#123; 1, 2, 3, 4 &#125; 这里我使用了forEach，forEach的第一个参数是数组的元素，第二个参数是数组的下标，第三个参数是数组本身 set的一些常用方法 12345678910111213let set = new Set([1, 2, 3, 4, 4]);console.log(set.has(1)); // trueconsole.log(set.size); // 4set.delete(1);console.log(set); // Set(3) &#123; 2, 3, 4 &#125;set.clear();// 清空setconsole.log(set); // Set(0) &#123;&#125;set.add(1);set.add(2);set.add(3);set.add(4);console.log(set); // Set(4) &#123; 1, 2, 3, 4 &#125; 以上就是set的基础用法"},{"title":"2024-7-18 每日一题","date":"2024-07-18T03:40:41.000Z","path":"2024/07/18/2024-7-18-每日一题/","excerpt":"没有优化的dijkstra 今天的每日一题是dijkstra的变形，我是图论低手，开始我只会写没有优化的dijkatra ，复杂度是O(n2)O(n^2)O(n2) 这里先介绍一下没有优化的dijkstra 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n, m, s; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; g(n + 1); for (int i = 0; i &lt; m; i++) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; g[u].push_back(&#123;v, w&#125;); &#125; // 没有优化的dijkstra算法 vector&lt;int&gt; dis(n + 1, INT_MAX); // dis[i]表示从s到i的最短距离 vector&lt;bool&gt; vis(n + 1, false); // 这里用来判断走没走过 dis[s] = 0; // 初始化是dis[s]=0 for (int i = 1; i &lt;= n; i++) &#123; int minn = INT_MAX, u = -1; for (int j = 1; j &lt;= n; j++) &#123; if (!vis[j] &amp;&amp; dis[j] &lt; minn) &#123; minn = dis[j]; u = j; &#125; // 这里是找到距离最小的点 &#125; if (u == -1) break; vis[u] = true; // 这里表示u点已经走过了 for (auto [v, w] : g[u]) &#123; if (dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; dis[i] &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 这里是一个没有优化的dijkstra算法"},{"title":"HTTP的状态码","date":"2024-07-17T09:02:35.000Z","path":"2024/07/17/HTTP的状态码/","excerpt":"五大类HTTP状态码 状态码范围 状态码类型 状态码描述 1xx 信息性状态码 接收的请求正在处理 2xx 成功状态码 请求正常处理完毕 3xx 重定向状态码 需要进行附加操作以完成请求 4xx 客户端错误状态码 服务器无法处理请求 5xx 服务器错误状态码 服务器处理请求出错"},{"title":"HTTP与HTTPS","date":"2024-07-16T14:24:45.000Z","path":"2024/07/16/HTTP与HTTPS/","excerpt":"HTTP的基本概念 HTTP 是超文本传输协议，主要分为三个部分，超文本，传输，协议。 HTTP是明文传输的所以是不安全的， HTTP是在计算机中两点之间传输超文本（文本、图片、音频、视频等）的协议。 HTTP和HTTPS的区别 HTTP和HTTPS的主要区别在于安全性和加密性。 HTTP HTTPS 明文传输 加密传输 80 443 无证书 有证书 HTTPS是在HTTP的基础上映入了SSL/TLS协议，SSL/TLS协议是在传输层对数据进行加密，保证数据的安全性。 HTTPS解决了HTTP的什么问题 HTTPS在通讯建立前采用非对称加密的方式进行交换密钥，后续就不再使用非堆成加密。 HTTPS在通讯过程中全部使用对称加密的方式进行加密密文传输。 公钥加密是一种使用两个不同的密钥加密或签署数据的方法，并使其中一个密钥（即公钥）可供任何人使用。另一个密钥称为私钥。用公钥加密的数据只能用私钥解密。由于这种方法使用两个密钥而不是一个，公钥加密也称为非对称加密。"},{"title":"暑假的计划","date":"2024-07-14T03:28:35.000Z","path":"2024/07/14/暑假的计划/","excerpt":"暑假的计划 因为水平不行，必须考虑找工作的事情，所以暑假准备学习一下前端的相关内容，具体的，根据牛客大佬的建议主要的路线如下 HTML、CSS、JavaScript基础。学完基础后，可以找个项目实战练习下。 JavaScript语法进阶。包括：作用域和闭包、this和对象原型等。相信我，JS语法，永远是面试中最重要的部分。 ES6语法。这部分属于JS新增的语法，面试必问。其中，关于 promise、async 等内容要尤其关注。 HTML5和CSS3。要熟悉其中的新特性。 前端框架：Vue.js和React。这两个框架至少要会一个。入门时，建议先学Vue.js，上手相对容易。但无论如何，同时掌握 Vue 和 React 才是合格的前端同学。"},{"title":"读入的个人理解","date":"2024-06-14T09:08:45.000Z","path":"2024/06/14/读入的个人理解/","excerpt":"如何读入 一般来说，题目会有这样的输入格式以标准的codeforces为例 Input The first line contains an integer ttt (1≤t≤1041 \\leq t \\leq 10^41≤t≤104) – the number of test cases. Each test case contains three integers lll, rrr, and kkk (0≤l≤r≤1090 \\leq l \\leq r \\leq 10^90≤l≤r≤109, 1≤k≤1091 \\leq k \\leq 10^91≤k≤109). 接下来会有一个输入的例子，如下 123456760 1 40 2 71 2 11 2 3582 74663 30 3 1 这种情况是很容易读入的，也是我最想看见的 读入的优化 123ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); 这样的语句可以在读入大量数据的时候提高读入的速度"},{"title":"算法复习分析","date":"2024-06-13T09:40:43.000Z","path":"2024/06/13/算法复习分析/","excerpt":"以下是今天的考试过程和结题报告好消息：全复习到了坏消息：考试的时候没看懂读入 T1整数数组的重复项大概的题意是将一个数组中的重复元素删去，给你的是一个有序的数组所以不需要考虑断断续续的情况问题是题目给的输入是’[1,2,2]’感觉不是很难处理写了一发1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string s; getline(cin, s); vector&lt;int&gt; nums; int len = s.size(); int x = 0; for (int i = 0; i &lt; len; i++) &#123; if (s[i] == &#x27;[&#x27;) &#123; continue; &#125; else if (s[i] == &#x27;,&#x27;) &#123; nums.push_back(x); x = 0; &#125; else if (s[i] == &#x27;]&#x27;) &#123; nums.push_back(x); &#125; else &#123; x = x * 10 + s[i] - &#x27;0&#x27;; &#125; &#125; // unique来删掉连续重复的元素，只保留 // unique返回的是最后一个不重复元素的下一个位置 // 这里一开始我忘记了unique的用法，然后就不会写了 auto pos = unique(nums.begin(), nums.end()); cout &lt;&lt; pos - nums.begin() &lt;&lt; endl; for (int i = 0; i &lt; pos - nums.begin(); i++) &#123; cout &lt;&lt; nums[i] &lt;&lt; &quot; &quot;; &#125; return 0;&#125;然后这道题到这里就卡住了，后来老师来改了输入，改成了 11 1 2 考试时候的代码所考的知识点双指针 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int x; vector&lt;int&gt; nums; while (cin &gt;&gt; x) &#123; nums.push_back(x); &#125; int n = nums.size(); int i = 0, j = 1; while (j &lt; n) &#123; if (nums[i] != nums[j])//如果不相等，就把j的值赋给i，然后j++ &#123; i++; nums[i] = nums[j];//这里是把j的值赋给i &#125; j++; &#125; int all = i + 1; cout &lt;&lt; all &lt;&lt; &#x27;,&#x27;; for (int k = 0; k &lt; all; k++) &#123; cout &lt;&lt; nums[k] &lt;&lt; &#x27;,&#x27;; &#125; return 0;&#125;"},{"title":"算法分析","date":"2024-06-12T09:40:28.000Z","path":"2024/06/12/算法分析/","excerpt":"复习报告 8-puzzle 洛谷上有相关的链接 洛谷p1379 注意题修改过，输出了路径，并且本题的目标函数是123456780 通过评测 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;vector&lt;int&gt;&gt; dir = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;int main()&#123; string s; cin &gt;&gt; s; string target = &quot;123456780&quot;; queue&lt;pair&lt;string, int&gt;&gt; q;//string记录状态，int记录步数 map&lt;string, string&gt; pre; //记录前面的状态 stack&lt;string&gt; ans; if (s == target) &#123; cout &lt;&lt; 0 &lt;&lt; endl; return 0; &#125; unordered_set&lt;string&gt; st; q.push(&#123;s, 0&#125;); st.insert(&#123;s&#125;); while (!q.empty()) &#123; auto [now, step] = q.front(); q.pop(); int pos = now.find(&quot;0&quot;); // cout &lt;&lt; pos &lt;&lt; endl; int xx = pos / 3, yy = pos % 3; // cout &lt;&lt; xx &lt;&lt; &#x27; &#x27; &lt;&lt; yy &lt;&lt; endl; for (int i = 0; i &lt; 4; i++) &#123; int nx = xx + dir[i][0], ny = yy + dir[i][1]; // cout &lt;&lt; nx &lt;&lt; &#x27; &#x27; &lt;&lt; ny &lt;&lt; endl; if (nx &gt;= 0 &amp;&amp; nx &lt; 3 &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; 3) &#123; string tmp = now; swap(tmp[nx * 3 + ny], tmp[xx * 3 + yy]); pre[tmp] = now; // cout &lt;&lt; now &lt;&lt; &#x27; &#x27; &lt;&lt; tmp &lt;&lt; endl; if (tmp == target) &#123; cout &lt;&lt; step + 1 &lt;&lt; endl; string pree = tmp; ans.push(pree); // cout &lt;&lt; pree &lt;&lt; &#x27; &#x27; &lt;&lt; pre[pree] &lt;&lt; endl; for (int i = 0; i &lt; step; i++) &#123; ans.push(pre[pree]); pree = pre[pree]; &#125; // ans.push(s); while (!ans.empty()) &#123; string noww = ans.top(); for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; cout &lt;&lt; noww[i * 3 + j] &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; endl; ans.pop(); &#125; return 0; &#125; else if (st.count(tmp) == 0) &#123; // cout &lt;&lt; tmp &lt;&lt; endl; st.insert(tmp); q.push(&#123;tmp, step + 1&#125;); &#125; &#125; &#125; &#125; return 0;&#125;"},{"title":"数值计算","date":"2024-05-27T13:51:53.000Z","path":"2024/05/27/数值计算/","excerpt":"数值计算期末考试复习 实验一 求近似值 123456789101112131415161718192021222324252627282930313233import mathdef case_one(num=8): I0 = 1 - math.exp(-1.0) # I0= input() # I0 = float(I0) 读入一个float形式的I0 # I0 =1-e^-1 I0 = float(&quot;&#123;0:.8f&#125;&quot;.format(I0)) print(I0) for k in range(1, num + 1): I1 = 1 - k * I0 I0 = I1 I0 = float(&quot;&#123;0:.8f&#125;&quot;.format(I0)) print(&quot;%d, %.8f&quot; % (k, I0))def case_two(num=8): I1 = 0.1124 for k in range(num, 0, -1): I0 = (1 - I1) / k I1 = I0 I1 = float(&quot;&#123;0:.4f&#125;&quot;.format(I1)) print(&quot;%d, %.4f&quot; % (k - 1, I1))if __name__ == &quot;__main__&quot;: chos1 = input() chos = int(chos1) if chos1 == &quot;1&quot;: case_one() elif chos1 == &quot;2&quot;: case_two() 第一题读入一个数值choose然后选择，第一个函数的推导公式是Tn+1=1−nTnT_{n+1}=1-nT_nTn+1​=1−nTn​，第二个函数的推导公式是Tn=1−Tn−1nT_n=\\frac{1-T_{n-1}}{n}Tn​=n1−Tn−1​​，然后输出结果其中中间的过程保留小数通过format函数保留小数点后8位，第二个函数保留小数点后4位。"},{"title":"图论——树","date":"2024-04-22T11:36:22.000Z","path":"2024/04/22/图论——树/","excerpt":""},{"title":"数据库绪论","date":"2024-03-30T14:44:16.000Z","path":"2024/03/30/数据库绪论/","excerpt":""},{"title":"时间复杂度","date":"2024-02-29T05:39:00.000Z","path":"2024/02/29/时间复杂度/","excerpt":""},{"title":"贪心","date":"2024-02-26T08:19:00.000Z","path":"2024/02/26/贪心/","excerpt":""},{"title":"二分","date":"2024-02-25T10:55:45.000Z","path":"2024/02/25/二分/","excerpt":""},{"title":"第二轮招新出题","date":"2024-02-25T10:49:40.000Z","path":"2024/02/25/第二轮招新出题-1/","excerpt":""},{"title":"codeforces round 923","date":"2024-02-09T07:55:10.000Z","path":"2024/02/09/Codeforces-Round-923-Div-3/","excerpt":""},{"title":"codeforces round 923","date":"2024-02-09T07:55:10.000Z","path":"2024/02/09/codeforces-round-923/","excerpt":""},{"title":"Codeforces Round 922 (Div. 2)","date":"2024-01-31T11:31:28.000Z","path":"2024/01/31/Codeforces-Round-922-Div-2/","excerpt":""},{"title":"拓扑排序","date":"2024-01-31T09:33:39.000Z","path":"2024/01/31/拓扑排序/","excerpt":""},{"title":"寒假新生第一周第一天","date":"2024-01-22T02:13:37.000Z","path":"2024/01/22/寒假新生第一周第一天/","excerpt":""}]